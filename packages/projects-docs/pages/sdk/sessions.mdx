---
title: Sessions
description: Learn how to connect to Sandboxes with the CodeSandbox SDK.
---

import { Callout } from 'nextra-theme-docs'

# Sessions

By default a session is bound to a user called `pitcher-host`. This user has write access to any API. We refer to this session as the "global" session.

```ts
const sandbox = await sdk.sandbox.create()
// "connect" creates a WebSocketSession
const session = await sandbox.connect()

// Now you have a session where you act as the `pitcher-host` user.
// Any action you do will be done as `pitcher-host` user.
await session.fs.writeTextFile('test.txt', 'Hello World');
```

<Callout>
When you run `whoami`, it will say that you are `root`. That's because we run every session inside a Docker container where you are `root`. However the container itself is started as the user of your session.
</Callout>

## Custom Sessions

You can choose to create your own user sessions with specific permissions, git access and even environment variables. Giving you the ability to align your SDK usage with best practice access control principles.

With the SDK, you get to decide where a user can act on behalf of your global session when they connect. You can select which permissions to grant them, and you can even isolate their actions from the global session.

### Permissions

By default a user has `write` access, but you can configure a session to have `read` access.

```ts
// Now configure a session that only has read access to the sandbox
const sandbox = await sdk.sandbox.create()
const session = await sandbox.connect({
  id: 'anonymous',
  permission: 'read'
})

// I have access to the normal sandbox api, but I only have read access
// This means I cannot write files or open shells, but I _can_ read them
await session.fs.writeTextFile('test.txt', 'Hello World'); // This will throw an error.
await session.fs.readTextFile('test.txt'); // This will work.
```

### Git

Passing the users git access token allows the user to use git commands inside the sandbox. Their permission level will be inherited from the git token. 

```ts
const sandbox = await sdk.sandbox.create()
const session = await sandbox.connect({
  id: 'anonymous',
  git: {
    accessToken: 'github-token',
    email: "foo@bar.com",
    name: "Foo Bar"
  }
})
```

### Environment variables

If you pass environment variables, these variables will be available to the user inside the commands and terminals that they run in the Sandbox.

```ts
const sandbox = await sdk.sandbox.create()
const session = await sandbox.connect({
  id: 'anonymous',
  env: {
    FOO: 'bar'
  }
})

const output = await session.commands.run('echo $FOO')
console.log(output) // bar
```

### Storage

Every session will have the same filesystem as the global session. This means that if one user creates a file inside the workspace folder (or even the home folder), other users will be able to see it with one exception. The `~/.private` folder will be private for each session. No other session (including the global session) will be able to read or write to files inside this folder.

<Callout>
The `~/.private` folder will not be persisted between restarts of the sandbox. This means that files inside this folder will disappear between restarts. 
</Callout>

## Browser Session

If you want your users to connect to the Sandbox from the browser you can create an endpoint that responds with a browser session:

```ts
export const GET = async ({ params }) => {
  const sandbox = await sdk.sandbox.resume(params.sandboxId);
  // Also default to global session, but can configure custom session
  const session = await sandbox.createBrowserSession();

  return session
}
```

And in the browser:

```ts
import { connectToSandbox } from '@codesandbox/sdk/browser';

const session = await connectToSandbox({
  id: 'some-sandbox',
  getSession: (id) => fetch(`/api/sandboxes/${id}`).then(res => res.json())
});

await session.fs.writeTextFile('test.txt', 'Hello World');
```

## Rest Session

The sandboxes also expose a Rest api which can be a more useful protocol to use as you do not have to manage an ongoing connection. The Rest session
is not as extensive, but supports most features.

```ts
const sandbox = await sdk.sandbox.resume('sandbox-id')
// Also defaults to global session, but can configure custom session
const session = await sandbox.createRestClient()

await session.fs.writeTextFile({ path: 'test.ext', content: 'Hello World' })
```
