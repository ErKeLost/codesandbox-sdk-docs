---
title: Sessions
description: Sessions allow you to create multiple users inside a single sandbox.
---

import { Callout } from 'nextra-theme-docs'

# Sessions

To interact with a Sandbox you have to create a session. The SDK offers different types of sessions depending on your needs:

- **WebSocket (default)**: A long lived WebSocket connection with minimum overhead to message passing. Can listen to port changes, shell outputs etc. Can be used in the browser
- **REST**: When you do not want to manage a connection, but rather do one off request/response
- **SSH**: When you want to interact with the full environment at low level

By default a session is bound to a user called `pitcher-host`. This user has write access to any API. We refer to this session as the "global" session. But you can choose
to create your own user sessions with specific permissions.

```ts
const sandbox = await sdk.sandbox.create()
const session = await sandbox.createSession()

// Now I have a session where I act as `pitcher-host` user.
// Any action I do will be done as `pitcher-host` user.
await sandbox.fs.writeTextFile('test.txt', 'Hello World');
```

<Callout>
When you run `whoami`, it will say you're `root`. That's because we run every session inside a Docker container where you are `root`. The container itself, however, is started as the user of your session.
</Callout>

Now, let's say you want a user to connect with the sandbox but don't want them to act on behalf of your global session. Perhaps you want them to have different permissions, or you want to isolate their actions from the global session.

```ts
// Now create a new session that only has read access to the sandbox
const sandbox = await sdk.sandbox.create()
const session = await sandbox.createSession({ user: 'anonymous', permission: 'read' })

// I have access to the normal sandbox api, but I only have read access
// This means I cannot write files or open shells, but I _can_ read them
await session.fs.writeTextFile('test.txt', 'Hello World'); // This will throw an error.
await session.fs.readTextFile('test.txt'); // This will work.

// I can also create sessions with write access
const session2 = await sandbox.createSession({
  user: 'some-user-reference',
  permission: 'write',
});
await session2.fs.writeTextFile('test.ext', 'Hello World'); // This will work
```

If you create a session with the same id as before (e.g., `my-session-id`), we will reuse the existing session.

Examples of use cases are:

- **Shared Branches / Sandboxes**: When building a collaborative code editor, you can allow multiple users to connect to the same branch and collaboratively edit files without the ability to affect each other. Every user can have their own secrets (like git token) stored in `~/.private` so they can commit and pull with their own credentials without sharing those with others
- **Anonymous Previews**: If you want to share a sandbox with someone else and give them access to reading files & shells, you can create a read-only session when they connect to the sandbox. This way, they can see what's running and how it works, but they cannot change the code. If they want to make changes, you can call `sandbox.fork()` to create a copy and give them access to a write session there

## Sessions in the Browser

If you want your users to connect to the Sandbox from the browser you can rather create a browser session and pass it to the client.

```ts
const sandbox = await sdk.sandbox.ref('sandbox-id');

// Pass this session to the browser
const session = await sandbox.createBrowserSession({
  user: 'some-user-reference',
  permission: 'write'
});
```

And in the browser:

```ts
import { connectToSandbox } from '@codesandbox/sdk/browser';

const session = await connectToSandbox(sessionFromServer);
```

## Sessions using Rest

The sandboxes also expose a Rest api which can be a more useful protocol to use as you do not have to manage an ongoing connection. The Rest session
is not as extensive, but supports most features.

```ts
const sandbox = sdk.sandbox.ref('sandbox-id')
const session = sandbox.createRestSession({
  user: 'some-user-reference',
  permission: 'write'
})

await session.fs.writeTextFile('test.ext', 'Hello World')
```

### Sessions using SSH

Not sure the use case here or how it works.

```ts
const sandbox = sdk.sandbox.ref('sandbox-id')
const session = sandbox.createSshSession({
  user: 'some-user-reference',
  permission: 'write'
})
```

## Storage

Every session will have the same filesystem as the global session. This means that if one user creates a file inside the workspace folder (or even the home folder), other users will be able to see it. There is one exception to this: the `~/.private` folder will be private for each session. No other session (including the global session) will be able to read or write to files inside this folder.

<Callout>
The `~/.private` folder will not be persisted between restarts of the sandbox. This means that files inside this folder will disappear between restarts. 
</Callout>
